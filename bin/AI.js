// Generated by CoffeeScript 1.6.3
/*
Some behaviour for the player to play against.
*/


(function() {
  window.AI = (function() {
    function AI(player, other_players, neutral_player) {
      this.player = player;
      this.other_players = other_players;
      this.neutral_player = neutral_player;
      this.defence = 20;
      this.attack = 20;
      this.expand = 20;
      this.updateGeneralStats();
      this.updatePlanetStats();
    }

    AI.prototype.tick = function() {
      Schedule.runEvery(80, function() {
        return this.updateGeneralStats();
      }, this);
      Schedule.runEvery(30, function() {
        return this.updatePlanetStats();
      }, this);
      return Schedule.runEvery(this.expand, function() {
        return this.makeExpansionMove();
      }, this);
    };

    AI.prototype.updatePlanetStats = function() {
      var planet, stats_planet, _i, _len, _ref, _results;
      this.planets = [];
      _ref = this.player.getPlanets();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        planet = _ref[_i];
        stats_planet = {};
        stats_planet.nearest_occupied = this.getNearestPlanet(planet, true);
        stats_planet.nearest_unoccupied = this.getNearestPlanet(planet, false);
        stats_planet.nearby_units = this.getNearbyUnits(planet);
        stats_planet.planet = planet;
        _results.push(this.planets.push(stats_planet));
      }
      return _results;
    };

    AI.prototype.updateGeneralStats = function() {
      return this.stats = {
        TOTAL_UNITS: 0
      };
    };

    AI.prototype.getNearestPlanet = function(planet, occupied) {
      var distance, i, min_distance, nearest_planet, other_planet, other_planets, other_player, _i, _j, _len, _len1, _ref;
      min_distance = false;
      nearest_planet = false;
      _ref = this.other_players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        other_player = _ref[_i];
        if (occupied && other_player === this.neutral_player) {
          continue;
        }
        if (!occupied && other_player !== this.neutral_player) {
          continue;
        }
        other_planets = other_player.getPlanets();
        for (i = _j = 0, _len1 = other_planets.length; _j < _len1; i = ++_j) {
          other_planet = other_planets[i];
          distance = other_planet.getPosition().distanceFrom(planet.getPosition());
          if (min_distance === false || distance < min_distance) {
            min_distance = distance;
            nearest_planet = i;
          }
        }
      }
      return other_planets[nearest_planet];
    };

    AI.prototype.getNearbyUnits = function(planet) {
      var max_distance, nearbyUnits, unit, _i, _len, _ref;
      nearbyUnits = new UnitCollection();
      max_distance = planet.getPosition().getR() + Planet.MAX_PLANET_RADIUS + Planet.UNIT_DISTANCE_FROM_PLANET + Planet.UNIT_DISTANCE_FROM_PLANET_VARIANCE;
      _ref = this.player.getUnits().getAll();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        unit = _ref[_i];
        if (unit.getPosition().distanceFrom(planet.getPosition()) <= max_distance) {
          nearbyUnits.add(unit);
        }
      }
      return nearbyUnits;
    };

    AI.prototype.makeExpansionMove = function() {
      var planet, _i, _len, _ref;
      if (this.neutral_player.getPlanets().length === 0) {
        return;
      }
      _ref = this.planets;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        planet = _ref[_i];
        if (planet.nearby_units.count() > Ownership.UNIT_COVERAGE_REQUIREMENT) {
          planet.nearby_units.sendTo(planet.nearest_unoccupied.getPosition());
        }
      }
      return console.log(planet);
    };

    AI.prototype.makeAttackMove = function() {};

    AI.prototype.makeDefenceMove = function() {};

    return AI;

  })();

}).call(this);
